// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/securityprovider"
	"github.com/oapi-codegen/runtime"
)

// Defines values for CountryNotFoundEnum.
const (
	CountryNotFound CountryNotFoundEnum = "country_not_found"
)

// Defines values for CurrencyNotFoundEnum.
const (
	CurrencyNotFound CurrencyNotFoundEnum = "currency_not_found"
)

// Defines values for CustomerTypeEnum.
const (
	Business CustomerTypeEnum = "business"
	Consumer CustomerTypeEnum = "consumer"
)

// Defines values for InternalAuthErrorEnum.
const (
	InternalAuthErrorEnumInternalAuthError InternalAuthErrorEnum = "internal_auth_error"
)

// Defines values for InvalidCouponCodeEnum.
const (
	InvalidCouponCodeEnumInvalidCouponCode InvalidCouponCodeEnum = "invalid_coupon_code"
)

// Defines values for InvalidEstimateQuantityEnum.
const (
	InvalidEstimateQuantityEnumInvalidEstimateQuantity InvalidEstimateQuantityEnum = "invalid_estimate_quantity"
)

// Defines values for InvalidEstimateResourceEnum.
const (
	InvalidEstimateResourceEnumInvalidEstimateResource InvalidEstimateResourceEnum = "invalid_estimate_resource"
)

// Defines values for MissingResourcesEnum.
const (
	MissingResources MissingResourcesEnum = "missing_resources"
)

// Defines values for PrivacyTypesEnum.
const (
	Private PrivacyTypesEnum = "private"
	Public  PrivacyTypesEnum = "public"
)

// Defines values for RateLimitReachedEnum.
const (
	RateLimitReachedEnumRateLimitReached RateLimitReachedEnum = "rate_limit_reached"
)

// Defines values for ValidationErrorEnum.
const (
	ValidationErrorEnumValidationError ValidationErrorEnum = "validation_error"
)

// Attachment defines model for Attachment.
type Attachment struct {
	Digest   *string `json:"digest,omitempty"`
	FileName *string `json:"file_name,omitempty"`
	FileSize *int    `json:"file_size,omitempty"`
	FileType *string `json:"file_type,omitempty"`
	Token    *string `json:"token,omitempty"`
	Url      *string `json:"url,omitempty"`
}

// CountryLookup All 'country[]' params are mutually exclusive, only one can be provided.
type CountryLookup struct {
	Id       *string `json:"id,omitempty"`
	IsoCode2 *string `json:"iso_code2,omitempty"`
	IsoCode3 *string `json:"iso_code3,omitempty"`
}

// CountryNotFoundEnum defines model for CountryNotFoundEnum.
type CountryNotFoundEnum string

// CountryNotFoundSchema No country was found matching any of the criteria provided in the arguments
type CountryNotFoundSchema struct {
	Code        *CountryNotFoundEnum    `json:"code,omitempty"`
	Description *string                 `json:"description,omitempty"`
	Detail      *map[string]interface{} `json:"detail,omitempty"`
}

// Currency defines model for Currency.
type Currency struct {
	Id      *string `json:"id,omitempty"`
	IsoCode *string `json:"iso_code,omitempty"`
	Name    *string `json:"name,omitempty"`
	Symbol  *string `json:"symbol,omitempty"`
}

// CurrencyLookup All 'currency[]' params are mutually exclusive, only one can be provided.
type CurrencyLookup struct {
	Id      *string `json:"id,omitempty"`
	IsoCode *string `json:"iso_code,omitempty"`
}

// CurrencyNotFoundEnum defines model for CurrencyNotFoundEnum.
type CurrencyNotFoundEnum string

// CurrencyNotFoundSchema No currency was found matching any of the criteria provided in the arguments
type CurrencyNotFoundSchema struct {
	Code        *CurrencyNotFoundEnum   `json:"code,omitempty"`
	Description *string                 `json:"description,omitempty"`
	Detail      *map[string]interface{} `json:"detail,omitempty"`
}

// CustomerTypeEnum defines model for CustomerTypeEnum.
type CustomerTypeEnum string

// DataCenter defines model for DataCenter.
type DataCenter struct {
	Country   *string `json:"country,omitempty"`
	Id        *string `json:"id,omitempty"`
	Name      *string `json:"name,omitempty"`
	Permalink *string `json:"permalink,omitempty"`
}

// GetPricingPrices200ResponsePrices defines model for GetPricingPrices200ResponsePrices.
type GetPricingPrices200ResponsePrices struct {
	Category    *string         `json:"category,omitempty"`
	Description *string         `json:"description,omitempty"`
	Resource    *string         `json:"resource,omitempty"`
	Variants    *[]PriceVariant `json:"variants,omitempty"`
}

// InternalAuthError defines model for InternalAuthError.
type InternalAuthError struct {
	Details *string `json:"details,omitempty"`
}

// InternalAuthErrorEnum defines model for InternalAuthErrorEnum.
type InternalAuthErrorEnum string

// InvalidCouponCode defines model for InvalidCouponCode.
type InvalidCouponCode struct {
	Code *string `json:"code,omitempty"`
}

// InvalidCouponCodeEnum defines model for InvalidCouponCodeEnum.
type InvalidCouponCodeEnum string

// InvalidEstimateQuantity defines model for InvalidEstimateQuantity.
type InvalidEstimateQuantity struct {
	Resource *string `json:"resource"`
}

// InvalidEstimateQuantityEnum defines model for InvalidEstimateQuantityEnum.
type InvalidEstimateQuantityEnum string

// InvalidEstimateQuantitySchema The quantity for the provided resource must be greater than zero
type InvalidEstimateQuantitySchema struct {
	Code        *InvalidEstimateQuantityEnum `json:"code,omitempty"`
	Description *string                      `json:"description,omitempty"`
	Detail      *InvalidEstimateQuantity     `json:"detail,omitempty"`
}

// InvalidEstimateResource defines model for InvalidEstimateResource.
type InvalidEstimateResource struct {
	Resource *string `json:"resource"`
}

// InvalidEstimateResourceEnum defines model for InvalidEstimateResourceEnum.
type InvalidEstimateResourceEnum string

// InvalidEstimateResourceSchema The provided resource is not valid
type InvalidEstimateResourceSchema struct {
	Code        *InvalidEstimateResourceEnum `json:"code,omitempty"`
	Description *string                      `json:"description,omitempty"`
	Detail      *InvalidEstimateResource     `json:"detail,omitempty"`
}

// MissingResourcesEnum defines model for MissingResourcesEnum.
type MissingResourcesEnum string

// MissingResourcesSchema You must provide at least one resource in the resources array
type MissingResourcesSchema struct {
	Code        *MissingResourcesEnum   `json:"code,omitempty"`
	Description *string                 `json:"description,omitempty"`
	Detail      *map[string]interface{} `json:"detail,omitempty"`
}

// OneOfCountryNotFoundCurrencyNotFound404Res defines model for OneOfCountryNotFoundCurrencyNotFound404Res.
type OneOfCountryNotFoundCurrencyNotFound404Res struct {
	union json.RawMessage
}

// OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res defines model for OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res.
type OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res struct {
	union json.RawMessage
}

// PaginationObject defines model for PaginationObject.
type PaginationObject struct {
	// CurrentPage The current page
	CurrentPage *int `json:"current_page,omitempty"`

	// LargeSet Is this a large set and therefore the total number of records cannot be returned?
	LargeSet *bool `json:"large_set,omitempty"`

	// PerPage The number of items per page
	PerPage *int `json:"per_page,omitempty"`

	// Total The total number of items across all pages
	Total *int `json:"total"`

	// TotalPages The total number of pages
	TotalPages *int `json:"total_pages"`
}

// Price defines model for Price.
type Price struct {
	Currency *[]Currency `json:"currency,omitempty"`
	Id       *string     `json:"id,omitempty"`
	Price    *float32    `json:"price,omitempty"`
}

// PriceVariant defines model for PriceVariant.
type PriceVariant struct {
	Default     *bool    `json:"default,omitempty"`
	Description *string  `json:"description"`
	Id          *string  `json:"id"`
	Prices      *[]Price `json:"prices,omitempty"`
}

// PricingEstimate defines model for PricingEstimate.
type PricingEstimate struct {
	Currency       *Currency                  `json:"currency,omitempty"`
	PdfUrl         *string                    `json:"pdf_url,omitempty"`
	PerHour        *float32                   `json:"per_hour,omitempty"`
	PerHourIncTax  *float32                   `json:"per_hour_inc_tax,omitempty"`
	PerMonth       *float32                   `json:"per_month,omitempty"`
	PerMonthIncTax *float32                   `json:"per_month_inc_tax,omitempty"`
	Resources      *[]PricingEstimateResource `json:"resources,omitempty"`
	TaxRate        *float32                   `json:"tax_rate,omitempty"`
}

// PricingEstimateResource defines model for PricingEstimateResource.
type PricingEstimateResource struct {
	Description    *string                `json:"description,omitempty"`
	Package        *VirtualMachinePackage `json:"package"`
	PerHour        *float32               `json:"per_hour,omitempty"`
	PerHourEach    *float32               `json:"per_hour_each,omitempty"`
	PerHourIncTax  *float32               `json:"per_hour_inc_tax,omitempty"`
	PerMonth       *float32               `json:"per_month,omitempty"`
	PerMonthEach   *float32               `json:"per_month_each,omitempty"`
	PerMonthIncTax *float32               `json:"per_month_inc_tax,omitempty"`
	Quantity       *int                   `json:"quantity,omitempty"`
	Resource       *string                `json:"resource,omitempty"`
}

// PricingEstimateResourceArguments defines model for PricingEstimateResourceArguments.
type PricingEstimateResourceArguments struct {
	Quantity *int    `json:"quantity,omitempty"`
	Resource *string `json:"resource,omitempty"`
}

// PrivacyTypesEnum defines model for PrivacyTypesEnum.
type PrivacyTypesEnum string

// RateLimitReached defines model for RateLimitReached.
type RateLimitReached struct {
	// TotalPermitted The total number of requests per minute that are permitted
	TotalPermitted *int `json:"total_permitted,omitempty"`
}

// RateLimitReachedEnum defines model for RateLimitReachedEnum.
type RateLimitReachedEnum string

// SignupCampaignArguments defines model for SignupCampaignArguments.
type SignupCampaignArguments struct {
	Content *string `json:"content,omitempty"`
	Id      *string `json:"id,omitempty"`
	Medium  *string `json:"medium,omitempty"`
	Name    *string `json:"name,omitempty"`
	Source  *string `json:"source,omitempty"`
	Term    *string `json:"term,omitempty"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Errors *[]string `json:"errors,omitempty"`
}

// ValidationErrorEnum defines model for ValidationErrorEnum.
type ValidationErrorEnum string

// VirtualMachinePackage defines model for VirtualMachinePackage.
type VirtualMachinePackage struct {
	CpuCores                      *int                        `json:"cpu_cores,omitempty"`
	Group                         *VirtualMachinePackageGroup `json:"group,omitempty"`
	Icon                          *Attachment                 `json:"icon"`
	Id                            *string                     `json:"id,omitempty"`
	Ipv4Addresses                 *int                        `json:"ipv4_addresses,omitempty"`
	MemoryInGb                    *int                        `json:"memory_in_gb,omitempty"`
	MonthlyBandwidthAllowanceInGb *int                        `json:"monthly_bandwidth_allowance_in_gb"`
	Name                          *string                     `json:"name,omitempty"`
	Permalink                     *string                     `json:"permalink,omitempty"`
	Privacy                       *PrivacyTypesEnum           `json:"privacy,omitempty"`
	StorageInGb                   *int                        `json:"storage_in_gb,omitempty"`
	UseDedicatedCpus              *bool                       `json:"use_dedicated_cpus,omitempty"`
}

// VirtualMachinePackageGroup defines model for VirtualMachinePackageGroup.
type VirtualMachinePackageGroup struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// APIAuthenticator403Response defines model for APIAuthenticator403Response.
type APIAuthenticator403Response struct {
	Code        *InternalAuthErrorEnum `json:"code,omitempty"`
	Description *string                `json:"description,omitempty"`
	Detail      *InternalAuthError     `json:"detail,omitempty"`
}

// APIAuthenticator429Response defines model for APIAuthenticator429Response.
type APIAuthenticator429Response struct {
	Code        *RateLimitReachedEnum `json:"code,omitempty"`
	Description *string               `json:"description,omitempty"`
	Detail      *RateLimitReached     `json:"detail,omitempty"`
}

// CountryNotFoundCurrencyNotFound404Res defines model for CountryNotFoundCurrencyNotFound404Res.
type CountryNotFoundCurrencyNotFound404Res = OneOfCountryNotFoundCurrencyNotFound404Res

// InvalidCouponCodeResponse defines model for InvalidCouponCodeResponse.
type InvalidCouponCodeResponse struct {
	Code        *InvalidCouponCodeEnum `json:"code,omitempty"`
	Description *string                `json:"description,omitempty"`
	Detail      *InvalidCouponCode     `json:"detail,omitempty"`
}

// InvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res defines model for InvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res.
type InvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res = OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res

// ValidationErrorResponse defines model for ValidationErrorResponse.
type ValidationErrorResponse struct {
	Code        *ValidationErrorEnum `json:"code,omitempty"`
	Description *string              `json:"description,omitempty"`
	Detail      *ValidationError     `json:"detail,omitempty"`
}

// PostPricingEstimateJSONBody defines parameters for PostPricingEstimate.
type PostPricingEstimateJSONBody struct {
	// Country All 'country[]' params are mutually exclusive, only one can be provided.
	Country CountryLookup `json:"country"`

	// Currency All 'currency[]' params are mutually exclusive, only one can be provided.
	Currency CurrencyLookup `json:"currency"`

	// CustomerName The customer's name
	CustomerName string                             `json:"customer_name"`
	CustomerType CustomerTypeEnum                   `json:"customer_type"`
	Resources    []PricingEstimateResourceArguments `json:"resources"`
}

// PostSignupsJSONBody defines parameters for PostSignups.
type PostSignupsJSONBody struct {
	Campaign *SignupCampaignArguments `json:"campaign,omitempty"`

	// Coupon The code for the coupon that will be applied to the first new organization created by the user
	Coupon *string `json:"coupon,omitempty"`

	// EmailAddress The e-mail address that should receive the welcome e-mail
	EmailAddress *string `json:"email_address,omitempty"`

	// VerifyWithEmail If true, the user will be sent an email to verify their e-mail address, and if false, the user will need to verify their e-mail address when they create an account in Identity
	VerifyWithEmail *bool `json:"verify_with_email,omitempty"`
}

// GetVirtualMachinePackagesParams defines parameters for GetVirtualMachinePackages.
type GetVirtualMachinePackagesParams struct {
	// Page The page number to request. If not provided, the first page will be returned.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of items to return per page. If not provided, the default value will be used.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// PostPricingEstimateJSONRequestBody defines body for PostPricingEstimate for application/json ContentType.
type PostPricingEstimateJSONRequestBody PostPricingEstimateJSONBody

// PostSignupsJSONRequestBody defines body for PostSignups for application/json ContentType.
type PostSignupsJSONRequestBody PostSignupsJSONBody

// AsCurrencyNotFoundSchema returns the union data inside the OneOfCountryNotFoundCurrencyNotFound404Res as a CurrencyNotFoundSchema
func (t OneOfCountryNotFoundCurrencyNotFound404Res) AsCurrencyNotFoundSchema() (CurrencyNotFoundSchema, error) {
	var body CurrencyNotFoundSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCurrencyNotFoundSchema overwrites any union data inside the OneOfCountryNotFoundCurrencyNotFound404Res as the provided CurrencyNotFoundSchema
func (t *OneOfCountryNotFoundCurrencyNotFound404Res) FromCurrencyNotFoundSchema(v CurrencyNotFoundSchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCurrencyNotFoundSchema performs a merge with any union data inside the OneOfCountryNotFoundCurrencyNotFound404Res, using the provided CurrencyNotFoundSchema
func (t *OneOfCountryNotFoundCurrencyNotFound404Res) MergeCurrencyNotFoundSchema(v CurrencyNotFoundSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCountryNotFoundSchema returns the union data inside the OneOfCountryNotFoundCurrencyNotFound404Res as a CountryNotFoundSchema
func (t OneOfCountryNotFoundCurrencyNotFound404Res) AsCountryNotFoundSchema() (CountryNotFoundSchema, error) {
	var body CountryNotFoundSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCountryNotFoundSchema overwrites any union data inside the OneOfCountryNotFoundCurrencyNotFound404Res as the provided CountryNotFoundSchema
func (t *OneOfCountryNotFoundCurrencyNotFound404Res) FromCountryNotFoundSchema(v CountryNotFoundSchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCountryNotFoundSchema performs a merge with any union data inside the OneOfCountryNotFoundCurrencyNotFound404Res, using the provided CountryNotFoundSchema
func (t *OneOfCountryNotFoundCurrencyNotFound404Res) MergeCountryNotFoundSchema(v CountryNotFoundSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OneOfCountryNotFoundCurrencyNotFound404Res) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OneOfCountryNotFoundCurrencyNotFound404Res) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMissingResourcesSchema returns the union data inside the OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res as a MissingResourcesSchema
func (t OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res) AsMissingResourcesSchema() (MissingResourcesSchema, error) {
	var body MissingResourcesSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMissingResourcesSchema overwrites any union data inside the OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res as the provided MissingResourcesSchema
func (t *OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res) FromMissingResourcesSchema(v MissingResourcesSchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMissingResourcesSchema performs a merge with any union data inside the OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res, using the provided MissingResourcesSchema
func (t *OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res) MergeMissingResourcesSchema(v MissingResourcesSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidEstimateResourceSchema returns the union data inside the OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res as a InvalidEstimateResourceSchema
func (t OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res) AsInvalidEstimateResourceSchema() (InvalidEstimateResourceSchema, error) {
	var body InvalidEstimateResourceSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidEstimateResourceSchema overwrites any union data inside the OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res as the provided InvalidEstimateResourceSchema
func (t *OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res) FromInvalidEstimateResourceSchema(v InvalidEstimateResourceSchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidEstimateResourceSchema performs a merge with any union data inside the OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res, using the provided InvalidEstimateResourceSchema
func (t *OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res) MergeInvalidEstimateResourceSchema(v InvalidEstimateResourceSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidEstimateQuantitySchema returns the union data inside the OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res as a InvalidEstimateQuantitySchema
func (t OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res) AsInvalidEstimateQuantitySchema() (InvalidEstimateQuantitySchema, error) {
	var body InvalidEstimateQuantitySchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidEstimateQuantitySchema overwrites any union data inside the OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res as the provided InvalidEstimateQuantitySchema
func (t *OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res) FromInvalidEstimateQuantitySchema(v InvalidEstimateQuantitySchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidEstimateQuantitySchema performs a merge with any union data inside the OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res, using the provided InvalidEstimateQuantitySchema
func (t *OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res) MergeInvalidEstimateQuantitySchema(v InvalidEstimateQuantitySchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OneOfInvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

const (
	clientVersion = "0.2.0" // x-release-please-version
)

var (
	ErrRequestFailed = errors.New("request was not successful")
	ErrNotFound      = errors.New("resource not found")
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, token string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}

	bearerTokenProvider, bearerTokenProviderErr := securityprovider.NewSecurityProviderBearerToken(token)
	if bearerTokenProviderErr != nil {
		return nil, bearerTokenProviderErr
	}

	client.RequestEditors = append(client.RequestEditors, bearerTokenProvider.Intercept)
	client.RequestEditors = append(client.RequestEditors, func(ctx context.Context, req *http.Request) error {
		req.Header.Set("User-Agent", "go-katapult/"+clientVersion)

		return nil
	})

	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}

	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetDataCenters request
	GetDataCenters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPricingEstimateWithBody request with any body
	PostPricingEstimateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPricingEstimate(ctx context.Context, body PostPricingEstimateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPricingPrices request
	GetPricingPrices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSignupsWithBody request with any body
	PostSignupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSignups(ctx context.Context, body PostSignupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStats request
	GetStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualMachinePackages request
	GetVirtualMachinePackages(ctx context.Context, params *GetVirtualMachinePackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetDataCenters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataCentersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPricingEstimateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPricingEstimateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPricingEstimate(ctx context.Context, body PostPricingEstimateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPricingEstimateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPricingPrices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPricingPricesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSignupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSignupsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSignups(ctx context.Context, body PostSignupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSignupsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualMachinePackages(ctx context.Context, params *GetVirtualMachinePackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualMachinePackagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetDataCentersRequest generates requests for GetDataCenters
func NewGetDataCentersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data_centers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPricingEstimateRequest calls the generic PostPricingEstimate builder with application/json body
func NewPostPricingEstimateRequest(server string, body PostPricingEstimateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPricingEstimateRequestWithBody(server, "application/json", bodyReader)
}

// NewPostPricingEstimateRequestWithBody generates requests for PostPricingEstimate with any type of body
func NewPostPricingEstimateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pricing/estimate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPricingPricesRequest generates requests for GetPricingPrices
func NewGetPricingPricesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pricing/prices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSignupsRequest calls the generic PostSignups builder with application/json body
func NewPostSignupsRequest(server string, body PostSignupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSignupsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSignupsRequestWithBody generates requests for PostSignups with any type of body
func NewPostSignupsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/signups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStatsRequest generates requests for GetStats
func NewGetStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualMachinePackagesRequest generates requests for GetVirtualMachinePackages
func NewGetVirtualMachinePackagesRequest(server string, params *GetVirtualMachinePackagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virtual_machine_packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, token string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, token, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetDataCentersWithResponse request
	GetDataCentersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDataCentersResponse, error)

	// PostPricingEstimateWithBodyWithResponse request with any body
	PostPricingEstimateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPricingEstimateResponse, error)

	PostPricingEstimateWithResponse(ctx context.Context, body PostPricingEstimateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPricingEstimateResponse, error)

	// GetPricingPricesWithResponse request
	GetPricingPricesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPricingPricesResponse, error)

	// PostSignupsWithBodyWithResponse request with any body
	PostSignupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSignupsResponse, error)

	PostSignupsWithResponse(ctx context.Context, body PostSignupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSignupsResponse, error)

	// GetStatsWithResponse request
	GetStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatsResponse, error)

	// GetVirtualMachinePackagesWithResponse request
	GetVirtualMachinePackagesWithResponse(ctx context.Context, params *GetVirtualMachinePackagesParams, reqEditors ...RequestEditorFn) (*GetVirtualMachinePackagesResponse, error)
}

type GetDataCentersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DataCenters []DataCenter `json:"data_centers"`
	}
	JSON403 *APIAuthenticator403Response
	JSON429 *APIAuthenticator429Response
}

// Status returns HTTPResponse.Status
func (r GetDataCentersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataCentersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPricingEstimateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Estimate The estimate, including breakdown, for a Katapult configuration
		Estimate PricingEstimate `json:"estimate"`
	}
	JSON400 *InvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res
	JSON403 *APIAuthenticator403Response
	JSON404 *CountryNotFoundCurrencyNotFound404Res
	JSON429 *APIAuthenticator429Response
}

// Status returns HTTPResponse.Status
func (r PostPricingEstimateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPricingEstimateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPricingPricesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Prices The prices in the default price plan
		Prices []GetPricingPrices200ResponsePrices `json:"prices"`
	}
	JSON403 *APIAuthenticator403Response
	JSON429 *APIAuthenticator429Response
}

// Status returns HTTPResponse.Status
func (r GetPricingPricesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPricingPricesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSignupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EmailAddress The e-mail address that was sent the welcome email
		EmailAddress *string `json:"email_address"`

		// Id The ID of the signup
		Id string `json:"id"`

		// Url The URL for the user to continue their signup process, only available if verify_with_email is false
		Url *string `json:"url"`
	}
	JSON403 *APIAuthenticator403Response
	JSON404 *InvalidCouponCodeResponse
	JSON422 *ValidationErrorResponse
	JSON429 *APIAuthenticator429Response
}

// Status returns HTTPResponse.Status
func (r PostSignupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSignupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TotalBlockStorage The total amount of block storage (in GB)
		TotalBlockStorage int `json:"total_block_storage"`

		// TotalCpuCores The total number of CPU cores
		TotalCpuCores int `json:"total_cpu_cores"`

		// TotalMemory The total amount of memory (in GB)
		TotalMemory int `json:"total_memory"`

		// TotalOrganizations The number of organizations
		TotalOrganizations int `json:"total_organizations"`

		// TotalVirtualMachinesLaunched The number of virtual machines launched (all time)
		TotalVirtualMachinesLaunched int `json:"total_virtual_machines_launched"`

		// TotalVirtualMachinesLaunchedToday The number of virtual machines launched today
		TotalVirtualMachinesLaunchedToday int `json:"total_virtual_machines_launched_today"`
	}
	JSON403 *APIAuthenticator403Response
	JSON429 *APIAuthenticator429Response
}

// Status returns HTTPResponse.Status
func (r GetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualMachinePackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Packages All available virtual machine packages
		Packages   []VirtualMachinePackage `json:"packages"`
		Pagination PaginationObject        `json:"pagination"`
	}
	JSON403 *APIAuthenticator403Response
	JSON429 *APIAuthenticator429Response
}

// Status returns HTTPResponse.Status
func (r GetVirtualMachinePackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualMachinePackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetDataCentersWithResponse request returning *GetDataCentersResponse
func (c *ClientWithResponses) GetDataCentersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDataCentersResponse, error) {
	rsp, err := c.GetDataCenters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}

	res, err := ParseGetDataCentersResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode == http.StatusNotFound {
		return res, ErrNotFound
	}

	if rsp.StatusCode < 200 || rsp.StatusCode >= 300 {
		return res, ErrRequestFailed
	}

	return res, nil
}

// PostPricingEstimateWithBodyWithResponse request with arbitrary body returning *PostPricingEstimateResponse
func (c *ClientWithResponses) PostPricingEstimateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPricingEstimateResponse, error) {
	rsp, err := c.PostPricingEstimateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	res, err := ParsePostPricingEstimateResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode == http.StatusNotFound {
		return res, ErrNotFound
	}

	if rsp.StatusCode < 200 || rsp.StatusCode >= 300 {
		return res, ErrRequestFailed
	}

	return res, nil
}

func (c *ClientWithResponses) PostPricingEstimateWithResponse(ctx context.Context, body PostPricingEstimateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPricingEstimateResponse, error) {
	rsp, err := c.PostPricingEstimate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	res, err := ParsePostPricingEstimateResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode == http.StatusNotFound {
		return res, ErrNotFound
	}

	if rsp.StatusCode < 200 || rsp.StatusCode >= 300 {
		return res, ErrRequestFailed
	}

	return res, nil
}

// GetPricingPricesWithResponse request returning *GetPricingPricesResponse
func (c *ClientWithResponses) GetPricingPricesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPricingPricesResponse, error) {
	rsp, err := c.GetPricingPrices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}

	res, err := ParseGetPricingPricesResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode == http.StatusNotFound {
		return res, ErrNotFound
	}

	if rsp.StatusCode < 200 || rsp.StatusCode >= 300 {
		return res, ErrRequestFailed
	}

	return res, nil
}

// PostSignupsWithBodyWithResponse request with arbitrary body returning *PostSignupsResponse
func (c *ClientWithResponses) PostSignupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSignupsResponse, error) {
	rsp, err := c.PostSignupsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	res, err := ParsePostSignupsResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode == http.StatusNotFound {
		return res, ErrNotFound
	}

	if rsp.StatusCode < 200 || rsp.StatusCode >= 300 {
		return res, ErrRequestFailed
	}

	return res, nil
}

func (c *ClientWithResponses) PostSignupsWithResponse(ctx context.Context, body PostSignupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSignupsResponse, error) {
	rsp, err := c.PostSignups(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}

	res, err := ParsePostSignupsResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode == http.StatusNotFound {
		return res, ErrNotFound
	}

	if rsp.StatusCode < 200 || rsp.StatusCode >= 300 {
		return res, ErrRequestFailed
	}

	return res, nil
}

// GetStatsWithResponse request returning *GetStatsResponse
func (c *ClientWithResponses) GetStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatsResponse, error) {
	rsp, err := c.GetStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}

	res, err := ParseGetStatsResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode == http.StatusNotFound {
		return res, ErrNotFound
	}

	if rsp.StatusCode < 200 || rsp.StatusCode >= 300 {
		return res, ErrRequestFailed
	}

	return res, nil
}

// GetVirtualMachinePackagesWithResponse request returning *GetVirtualMachinePackagesResponse
func (c *ClientWithResponses) GetVirtualMachinePackagesWithResponse(ctx context.Context, params *GetVirtualMachinePackagesParams, reqEditors ...RequestEditorFn) (*GetVirtualMachinePackagesResponse, error) {
	rsp, err := c.GetVirtualMachinePackages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}

	res, err := ParseGetVirtualMachinePackagesResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode == http.StatusNotFound {
		return res, ErrNotFound
	}

	if rsp.StatusCode < 200 || rsp.StatusCode >= 300 {
		return res, ErrRequestFailed
	}

	return res, nil
}

// ParseGetDataCentersResponse parses an HTTP response from a GetDataCentersWithResponse call
func ParseGetDataCentersResponse(rsp *http.Response) (*GetDataCentersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataCentersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DataCenters []DataCenter `json:"data_centers"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIAuthenticator403Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIAuthenticator429Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParsePostPricingEstimateResponse parses an HTTP response from a PostPricingEstimateWithResponse call
func ParsePostPricingEstimateResponse(rsp *http.Response) (*PostPricingEstimateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPricingEstimateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Estimate The estimate, including breakdown, for a Katapult configuration
			Estimate PricingEstimate `json:"estimate"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest InvalidEstimateQuantityInvalidEstimateResourceMissingResources400Res
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIAuthenticator403Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CountryNotFoundCurrencyNotFound404Res
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIAuthenticator429Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetPricingPricesResponse parses an HTTP response from a GetPricingPricesWithResponse call
func ParseGetPricingPricesResponse(rsp *http.Response) (*GetPricingPricesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPricingPricesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Prices The prices in the default price plan
			Prices []GetPricingPrices200ResponsePrices `json:"prices"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIAuthenticator403Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIAuthenticator429Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParsePostSignupsResponse parses an HTTP response from a PostSignupsWithResponse call
func ParsePostSignupsResponse(rsp *http.Response) (*PostSignupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSignupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EmailAddress The e-mail address that was sent the welcome email
			EmailAddress *string `json:"email_address"`

			// Id The ID of the signup
			Id string `json:"id"`

			// Url The URL for the user to continue their signup process, only available if verify_with_email is false
			Url *string `json:"url"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIAuthenticator403Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest InvalidCouponCodeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIAuthenticator429Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetStatsResponse parses an HTTP response from a GetStatsWithResponse call
func ParseGetStatsResponse(rsp *http.Response) (*GetStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TotalBlockStorage The total amount of block storage (in GB)
			TotalBlockStorage int `json:"total_block_storage"`

			// TotalCpuCores The total number of CPU cores
			TotalCpuCores int `json:"total_cpu_cores"`

			// TotalMemory The total amount of memory (in GB)
			TotalMemory int `json:"total_memory"`

			// TotalOrganizations The number of organizations
			TotalOrganizations int `json:"total_organizations"`

			// TotalVirtualMachinesLaunched The number of virtual machines launched (all time)
			TotalVirtualMachinesLaunched int `json:"total_virtual_machines_launched"`

			// TotalVirtualMachinesLaunchedToday The number of virtual machines launched today
			TotalVirtualMachinesLaunchedToday int `json:"total_virtual_machines_launched_today"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIAuthenticator403Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIAuthenticator429Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetVirtualMachinePackagesResponse parses an HTTP response from a GetVirtualMachinePackagesWithResponse call
func ParseGetVirtualMachinePackagesResponse(rsp *http.Response) (*GetVirtualMachinePackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualMachinePackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Packages All available virtual machine packages
			Packages   []VirtualMachinePackage `json:"packages"`
			Pagination PaginationObject        `json:"pagination"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIAuthenticator403Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIAuthenticator429Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}
